const VulnerableCoin = artifacts.require("VulnerableCoin");
const Evil3 = artifacts.require("Evil3");

describe('Evil3', function() {
  let primaryAddress, secondaryAddress, vulnerableCoin, evil;
  let normalBuyAmount = new web3.BigNumber(web3.toWei(3));
  let evilBuyAmount = new web3.BigNumber(web3.toWei(2));

  before(function(done) {
    primaryAddress = null;
    secondaryAddress = null;
    vulnerableCoin = null;
    evil = null;

    web3.eth.getAccounts(function(err, res) {
      let vulnerableFuture, evilFuture;
      primaryAddress = res[0];
      secondaryAddress = res[1];
      vulnerableFuture = VulnerableCoin.new({from: primaryAddress});
      evilFuture = vulnerableFuture.then((contract) => {
        vulnerableCoin = contract;
        return Evil3.new(vulnerableCoin.address, {from: primaryAddress});
      });

      evilFuture.then((contract) => {
        evil = contract;
        done();
      });
    });
  });

  it("should not withdraw double the amount deposited due to one reentrance", function(done) {
    const futureNormalBuy = vulnerableCoin.buy.sendTransaction({
      from: secondaryAddress,
      to: vulnerableCoin.address,
      value: normalBuyAmount
    });
    const futureEvilBuy = evil.enter.sendTransaction(evilBuyAmount, {
      from: primaryAddress,
      to: evil.address,
      value: evilBuyAmount
    });
    const futureBuys = Promise.all([futureNormalBuy, futureEvilBuy]);

    futureBuys.then( (results) => {
      const futureEvilWithdraw = evil.exit.sendTransaction({
        from: primaryAddress,
        to: evil.address,
        value: 0,
        gas: 3000000
      });

      futureEvilWithdraw.then( (result) => {
        assert.fail("withdrawal after theft should raise exception");

      }, (result) => {
        // Because we don't withdraw the evil amount at all the normal buyer balance is unaffected
        const amountLeft = normalBuyAmount.add(evilBuyAmount);
        const amountEvil = new web3.BigNumber(0);
        const vcBalance = web3.eth.getBalance(vulnerableCoin.address);
        const eBalance = web3.eth.getBalance(evil.address);
        assert.equal(vcBalance.valueOf(), amountLeft.valueOf(), "Improper amount of ether left in vulnerable contract");
        assert.equal(eBalance.valueOf(), amountEvil.valueOf(), "Improper amount of ether found in evil contract");
        done();
      });
    });
  });

  it("should be able to let normal user withdraw", function(done) {
    const futureNormalWithdrawAfterTheft = vulnerableCoin.withdrawExternalLast.sendTransaction({
      from: secondaryAddress,
      to: vulnerableCoin.address,
      value: 0
    });
    futureNormalWithdrawAfterTheft.then( (result) => {
      const amountLeft = evilBuyAmount;
      const vcBalance = web3.eth.getBalance(vulnerableCoin.address);
      assert.equal(vcBalance.valueOf(), amountLeft.valueOf(), "Improper amount of ether left in vulnerable contract");
      done();
    });
  });
});
